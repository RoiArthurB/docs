---
sidebar_position: 5
---

# reverse

Manage reverse port forwarding.

Reverse port forwarding (reverse tunnel) allows you to listen on a socket address on the device. When an app on Android connects to that address, the connection will be forward to Tango.

```ts
declare class AdbReverseCommand {
  list(): Promise<AdbForwardListener[]>;

  addExternal(deviceAddress: string, localAddress: string): Promise<string>;

  add(
    deviceAddress: string,
    handler: AdbIncomingSocketHandler,
    localAddress?: string,
  ): Promise<string>;

  remove(deviceAddress: string): Promise<void>;
}
```

## Errors

```ts
declare class AdbReverseError extends Error {}

declare class AdbReverseNotSupportedError extends AdbReverseError {}
```

ADB daemon on Android 8 and below had a bug that prevented reverse port forwarding from working when ADB is connected over Wi-Fi. When this happens, an `AdbReverseNotSupportedError` will be thrown.

ADB daemon may also return other errors, a general `AdbReverseError` will be thrown in this case. The `message` field contains a human-readable error message generated by ADB daemon.

## List existing port forwards

```ts
interface AdbForwardListener {
  deviceSerial: string;
  localName: string;
  remoteName: string;
}

declare class AdbReverseCommand {
  list(): Promise<AdbForwardListener[]>;
}
```

The returned `AdbForwardListener` objects contain the following fields:

- `deviceSerial`: Serial number of the device. For reverse tunnels, it might be `UsbFfs` for USB connections.
- `localName`: Socket address listening on device
- `remoteName`: Socket address to forward to on host

:::info[Equivalent ADB command]

```sh
adb reverse --list
```

:::

## Add an external port forwarding

```ts
declare class AdbReverseCommand {
  addExternal(deviceAddress: string, localAddress: string): Promise<string>;
}
```

Add an external (unmanaged) port forwarding to the device. When apps on device connects to `deviceAddress`, ADB daemon forwards the connection to the transport, and the transport forwards the connection to `localAddress`.

### `deviceAddress`

The socket address to listen on the device. The format is `transport:address`, where `transport` is the transport name (e.g. `tcp`, `localabstract`, `localfilesystem`, etc.), and `address` is the address to listen on.

If `deviceAddress` is `tcp:0`, ADB daemon will choose an available port on the device. On Android 8 and above, the chosen port will be returned. Otherwise, the return value will be the same as `deviceAddress`.

If a reverse tunnel already exists with the same `deviceAddress`, the operation will fail silently. Use `list()` to check for existing tunnels and `remove()` to remove them if necessary.

### `localAddress`

The address to forward the connection to. The format is `transport:address`, where `transport` is the transport name (e.g. `tcp`, `unix`, etc.), and `address` is the address to forward the connection to.

The exact meaning of `localAddress` depends on the runtime and transport. Some runtime, like Web, may not be able to connect to TCP sockets. In this case, adding an external port forwarding will not work.

### Example

```ts transpile
const port = await adb.reverse.addExternal("tcp:0", "tcp:localhost:1234");
console.log(port); // tcp:38324
```

:::info[Equivalent ADB command]

```sh
adb reverse tcp:0 tcp:localhost:1234
```

:::

## Add a managed port forwarding

```ts
type AdbIncomingSocketHandler = (socket: AdbSocket) => ValueOrPromise<void>;

declare class AdbReverseCommand {
  add(
    deviceAddress: string,
    handler: AdbIncomingSocketHandler,
    localAddress?: string,
  ): Promise<string>;
}
```

Add a managed port forwarding to the device. When apps on device connects to `deviceAddress`, ADB daemon forwards the connection to the transport, and the transport will call `handler` with the socket.

This method is guaranteed to work on all transports. Some transports, like the server transport, might emulate the behavior by listening on a TCP port and forwarding the connection to the handler.

### `deviceAddress`

Read the [`addExternal`](#deviceaddress) section for more information on `deviceAddress`.

### `handler`

The handler is a function that takes an `AdbSocket` object as its only argument. The handler should only initialize the connection and return immediately. The `AdbSocket` object is valid even after the handler returns, until the socket is closed by either side.

See the [Socket](./socket.mdx) page for how to use the `AdbSocket` object.

The transport will wait for the handler to return, before sending a socket open response to the device.

If the handler throws an error, the transport will suppress the error, and send a socket open failed response to the device. ADB daemon will then close the connection.

### `localAddress`

The meaning of `localAddress` depends on the transport:

| Transport            | Valid values                                                                                 | Default value                              |
| -------------------- | -------------------------------------------------------------------------------------------- | ------------------------------------------ |
| `AdbDaemonTransport` | Any string that uniquely identifies the handler                                              | A random string                            |
| `AdbServerTransport` | Any available TCP or Unix socket address (e.g. `tcp:0.0.0.0:1234` or `unix:/var/opt/socket`) | Automatically choose an available TCP port |

:::danger[READ ALL STREAMS!]

ADB is a multiplexing protocol (multiple logic streams are transferred over one connection), so blocking one stream will block all other streams.

You must continuously read from all incoming streams (either by piping them to `WritableStream`s or calling `reader.read()` in a loop) to prevent this from happening.

If the remaining data is not needed, `stream.cancel()` (or `reader.cancel()` if using a reader) can be called to discard them.

:::

### Example

Creates an echo server.

```ts transpile
import { encodeUtf8 } from "@yume-chan/adb";
import { DecodeUtf8Stream } from "@yume-chan/stream-extra";

const address = await adb.reverse.add("tcp:1234", (socket) => {
  const writer = socket.writable.getWriter();
  // Don't await the promise, otherwise the transport will block
  socket.readable.pipeTo(
    new WriteableStream({
      async write(chunk) {
        await writer.write(chunk);
      },
    }),
  ).then(() => {
    // The socket is closed
  }, (error) => {
    // An error occurred
  });
});
```

:::info[Equivalent ADB command]

There is no equivalent ADB command.

:::

## Remove a port forwarding

```ts
declare class AdbReverseCommand {
  remove(deviceAddress: string): Promise<void>;
}
```

Remove a port forwarding from the device using the socket address on device.

### Example

```ts transpile
await adb.reverse.remove("tcp:1234");
```

:::info[Equivalent ADB command]

```sh
adb reverse --remove tcp:1234
```

:::

## Remove all port forwardings

```ts
declare class AdbReverseCommand {
  removeAll(): Promise<void>;
}
```

Remove all port forwardings from the device.

Be careful when using this method, as it will remove all port forwardings, including those added by other apps.

### Example

```ts transpile
await adb.reverse.removeAll();
```

:::info[Equivalent ADB command]

```sh
adb reverse --remove-all
```

:::
