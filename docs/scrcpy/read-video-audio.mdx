---
sidebar_position: 7
---

# Read video and audio streams

## With `@yume-chan/scrcpy`

If you have a `ReadableStream<Uint8Array>` that reads from the video socket:

```ts transpile
import { ScrcpyOptions2_1, ScrcpyVideoStreamPacket } from "@yume-chan/scrcpy";

const options = new ScrcpyOptions2_1({
    // use the same version and options when starting the server
});

const videoSocket: ReadableStream<Uint8Array>; // get the stream yourself

// Parse video socket metadata
const { metadata: videoMetadata, stream: videoStream } =
    await options.parseVideoStreamMetadata(videoSocket);

const videoPacketStream: ReadableStream<ScrcpyMediaStreamPacket> =
    videoStream.pipeThrough(options.createMediaStreamTransformer());
// Read from `videoPacketStream`
```

Reading audio stream is similar, only replacing `parseVideoStreamMetadata` with `parseAudioStreamMetadata`.

## With `@yume-chan/adb-scrcpy`

When video is enabled (`video: false` not exist in options), `AdbScrcpyClient.videoStream` is a `Promise` that resolves to `AdbScrcpyVideoStream`. It invokes `options.parseVideoStreamMetadata` and `options.createMediaStreamTransformer` internally.

```ts transpile
if (client.videoSteam) {
    const { metadata: videoMetadata, stream: videoPacketStream } =
        await client.videoStream;
    // Read from `videoPacketStream`
}
```

The return values of `options.parseVideoStreamMetadata` and `await client.videoStream` may look similar, but the type of `stream` is different:

|                                    | `metadata`                  | `stream`                                  |
| ---------------------------------- | --------------------------- | ----------------------------------------- |
| `options.parseVideoStreamMetadata` | `ScrcpyMediaStreamMetadata` | `ReadableStream<Uint8Array>`              |
| `await client.videoStream`         | `ScrcpyMediaStreamMetadata` | `ReadableStream<ScrcpyMediaStreamPacket>` |

## Decode and render video

Tango provides packages to decode and render video packets in Web browsers:

### `@yume-chan/scrcpy-decoder-tinyh264`

Decode and render H.264 streams in Web browsers using TinyH264, the (now deprecated and removed) Android H.264 software decoder.

The video stream will be decoded into YUV frames on CPU, then converted to RGB using a WebGL shader (using GPU). It's slow, and only supports H.264 main profile at level 4, but works on most browsers.

```sh npm2yarn
npm install @yume-chan/scrcpy-decoder-tinyh264
```

```ts transpile
import { TinyH264Decoder } from "@yume-chan/scrcpy-decoder-tinyh264";

const decoder = new TinyH264Decoder();
document.body.appendChild(decoder.renderer);

videoPacketStream // from above
    .pipeTo(decoder.writable)
    .catch(() => {});
```

#### Limit profile/level

Because it only supports Baseline level 4 codec, but many newer devices default to higher profiles/levels, you can limit it by using the `codecOptions` option:

```ts transpile
import { TinyH264Decoder } from "@yume-chan/scrcpy-decoder-tinyh264";

const H264Capabilities = TinyH264Decoder.capabilities.h264;

new ScrcpyOptions1_24({
    codecOptions: new CodecOptions({
        profile: H264Capabilities.maxProfile,
        level: H264Capabilities.maxLevel,
    }),
});
```

However, it can fail on some very old devices that doesn't even support Baseline level 4 codec. If that happens, You can retry starting the server without the `codecOptions` option

### `@yume-chan/scrcpy-decoder-webcodecs`

Decode and render H.264 and H.265 streams in Web browsers using [WebCodecs API](https://developer.mozilla.org/en-US/docs/Web/API/WebCodecs_API), the new Web standard for hardware-accelerated video decoding.

It's fast, uses less hardware resources, and supports more H.264 and H.265 profiles and levels. However, it's only available in recent versions of Chrome and Safari.

```sh npm2yarn
npm install @yume-chan/scrcpy-decoder-webcodecs
```

The usage is same as `@yume-chan/scrcpy-decoder-tinyh264`:

```ts transpile
import { WebCodecsDecoder } from "@yume-chan/scrcpy-decoder-webcodecs";

const decoder = new WebCodecsDecoder();
document.body.appendChild(decoder.renderer);

videoPacketStream // from above
    .pipeTo(decoder.writable)
    .catch(() => {});
```
