---
sidebar_position: 7
---

# Handle video stream

## With `@yume-chan/scrcpy`

If you have a `ReadableStream<Uint8Array>` that reads from the video socket, use `options` to parse the metadata and create a packet stream.

```ts transpile
import { ScrcpyOptions2_1, ScrcpyVideoStreamPacket } from "@yume-chan/scrcpy";

const options = new ScrcpyOptions2_1({
  // use the same version and options when starting the server
});

const videoSocket: ReadableStream<Uint8Array>; // get the stream yourself

// Parse video socket metadata
const { metadata: videoMetadata, stream: videoStream } =
  await options.parseVideoStreamMetadata(videoSocket);

const videoPacketStream: ReadableStream<ScrcpyMediaStreamPacket> =
  videoStream.pipeThrough(options.createMediaStreamTransformer());

videoPacketStream
  .pipeTo(
    new WritableStream({
      write(packet: ScrcpyMediaStreamPacket) {
        switch (packet.type) {
          case "configuration":
            // Handle configuration packet
            console.log(packet.data);
            break;
          case "data":
            // Handle data packet
            console.log(packet.keyframe, packet.pts, packet.data);
            break;
        }
      },
    })
  )
  .catch((e) => {
    console.error(e);
  });
```

## With `@yume-chan/adb-scrcpy`

When video is enabled (`video: false` not exist in options), `AdbScrcpyClient.videoStream` is a `Promise` that resolves to `AdbScrcpyVideoStream`.

```ts transpile
if (client.videoSteam) {
  const { metadata: videoMetadata, stream: videoPacketStream } =
    await client.videoStream;

  videoPacketStream
    .pipeTo(
      new WritableStream({
        write(packet: ScrcpyMediaStreamPacket) {
          switch (packet.type) {
            case "configuration":
              // Handle configuration packet
              console.log(packet.data);
              break;
            case "data":
              // Handle data packet
              console.log(packet.keyframe, packet.pts, packet.data);
              break;
          }
        },
      })
    )
    .catch((e) => {
      console.error(e);
    });
}
```

It uses `options.parseVideoStreamMetadata` and `options.createMediaStreamTransformer` internally, so the returned `videoPacketStream` is the same as the one created manually.

## Decode and render video

Tango provides packages to decode and render video packets in Web browsers:

- [Tiny H264 decoder](/scrcpy/video/tiny-h264)
- [WebCodecs decoder](/scrcpy/video/web-codecs)

To use these decoders, the `sendFrameMeta` options must be `true` (the default value).

Decoding and playing video outside the browser is out of scope for this library. It will depend on the platform, UI framework, and media library you use.
