---
sidebar_position: 9
---

# Consumable pattern

Web Streams API doesn't provide a way to track where the data is, for example:

```ts
new ReadableStream({
    start(controller) {
        controller.enqueue(new Uint8Array([1, 2, 3]));
        controller.enqueue(new Uint8Array([4, 5, 6]));
        controller.close();
    }
}).pipeThrough(new TransformStream({
    transform(chunk, controller) {
        console.log(chunk);
        controller.enqueue(chunk);
    }
})).pipeTo(new WritableStream({
    write(chunk) {
        console.log(chunk);
    }
}));
```

In `ReadableStream`, `controller.enqueue` is a synchronous operation, the data source can't know where the data is going and when it's finally consumed.

If you want to reuse a `Uint8Array` to reduce memory allocation and GC overhead (to have better performance), you can't do it with the Web Streams API.

## `Consumable<T>`

The `Consumable` class is a wrapper around a value of type `T`. It allows the consumer to tell the producer when the value is no longer needed.

```ts
import { Consumable } from '@yume-chan/stream-extra';

function useData(data: Consumable<Uint8Array>) {
    console.log(data.value); // use the value
    data.consume();
}

async function produceData() {
    const data = new Consumable(new Uint8Array([1, 2, 3]));
    useData(data);
    await data.consumed;
}
```

Let's use the `Consumable` pattern to re-write the previous example:

```ts
import { Consumable, ReadableStream, TransformStream, WritableStream } from '@yume-chan/stream-extra';

const buffer = new Uint8Array(3);

new ReadableStream({
    start(controller) {
        buffer[0] = 1;
        buffer[1] = 2;
        buffer[2] = 3;

        const consumable1 = new Consumable(buffer);
        controller.enqueue(consumable1);
        await consumable1.consumed;

        buffer[0] = 4;
        buffer[1] = 5;
        buffer[2] = 6;

        const consumable2 = new Consumable(buffer);
        controller.enqueue(consumable2);
        await consumable2.consumed;

        controller.close();
    }
}).pipeThrough(new TransformStream({
    transform(chunk, controller) {
        console.log(chunk.value);
        controller.enqueue(chunk);
    }
})).pipeTo(new WritableStream({
    write(chunk) {
        console.log(chunk.value);
        chunk.consume();
    }
}));
```

## `tryConsume`

`Consumable` provides a helper method `tryConsume` to simplify the code:

```ts
import { Consumable } from '@yume-chan/stream-extra';

function useData(data: Consumable<Uint8Array>) {
    data.tryConsume(value => {
        console.log(value);
    });
}
```

`tryConsume` will call the callback immediately with the value, and mark the `Consumable` as consumed when the callback returns. If the callback returns a `Promise`, `tryConsume` will wait for the `Promise` to be settled.

### Improve debugging experience

Normally when piping data around streams, Chrome DevTools doesn't track the data flow, so the call stack is always empty:

```ts
import { ReadableStream, WritableStream } from '@yume-chan/stream-extra';

new ReadableStream({
    start(controller) {
        controller.enqueue(new Uint8Array([1, 2, 3]));
        controller.close();
    }
}).pipeTo(new WritableStream({
    write(chunk) {
        debugger; // Here the call stack is empty: it doesn't tell you where the `chunk` comes from
    }
}));
```

With `tryConsume`, `Consumable` will synthesis a call stack for you using [`console.createTask`](https://developer.chrome.com/blog/devtools-modern-web-debugging/):

```ts
import { Consumable, ReadableStream, WritableStream } from '@yume-chan/stream-extra';

new ReadableStream({
    start(controller) {
        controller.enqueue(new Consumable(new Uint8Array([1, 2, 3])));
        controller.close();
    }
}).pipeTo(new WritableStream({
    write(chunk) {
        chunk.tryConsume(value => {
            debugger; // The call stack will point to `new Consumable(new Uint8Array([1, 2, 3]))`
        });
    }
}));
```

## Upcoming changes

In current version, almost all `WritableStream`s requires `Consumable<T>` as input. In next version, these `WritableStream`s will accept both `T` and `Consumable<T>`, so you don't need to wrap the value with `Consumable` if you don't need to track the consumption. Of course, you will lose the async stack tracking feature as well.

```ts
import { WritableStream, MaybeConsumable } from '@yume-chan/stream-extra';

declare const stream: WritableStream<MaybeConsumable<Uint8Array>>;

const writer = stream.getWriter();
await writer.write(new Consumable(new Uint8Array([4, 5, 6])); // Still works
await writer.write(new Uint8Array([1, 2, 3])); // Now also works
```

For example, a blob stream can be directly piped into a `WritableStream`:

```ts
// Current version
blob.stream().pipeThrough(new WrapConsumableStream()).pipeTo(writable);

// Next version
blob.stream().pipeTo(writable);
```
